# -*- coding: utf-8 -*-
"""Milestone_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jcZPidBI164tFfRpeKe72QRskUFDm8YZ
"""

print("Milestone 3: Frequency Distribution and Data Visualization")
print("------------------------------------------")
print("Name: Mahinur Rahman Mahin")
print("ID: 242014165")
print("------------------------------------------")

"""## **A. Introduction**"""

print("Variable Selection:")
print("For this analysis, I have selected the variable from my dataset.")

print("\nFrequency Distribution Table:")
print("I have grouped the data into different intervals and calculated the frequency for each interval.")

"""# **B. Dataset**

### Data Loading and Initial Inspection
"""

# üåæ Milestone 3: Data Visualization
# This report presents the structure, summary, and sample visualization
# for the Agriculture Crop Yield Dataset.

# ----------------------------
# üìä Agriculture Crop Yield Dataset Description

dataset_description = """
Column Name           Description
-------------------------------------------------------------
Region                Geographical region where the crop is grown (North, East, South, West)
Soil_Type             Type of soil (Clay, Sandy, Loam, Silt, Peaty, Chalky)
Crop                  Type of crop grown (Wheat, Rice, Maize, Barley, Soybean, Cotton)
Rainfall_mm           Amount of rainfall (in millimeters) during crop growth
Temperature_Celsius   Average temperature during crop growth (C)
Fertilizer_Used       Indicates fertilizer use (True = Yes, False = No)
Irrigation_Used       Indicates irrigation use (True = Yes, False = No)
Weather_Condition     Predominant weather condition (Sunny, Rainy, Cloudy)
Days_to_Harvest       Number of days required for the crop to be harvested
Yield_tons_per_hectare Total yield (in tons per hectare)
"""
print(dataset_description)

# ----------------------------
# üìà Summary Statistics
summary_statistics = """
Total records: 1000000

Regions:
North - 25%
West - 25%
Other - 50%

Soil Types:
Sandy - 17%
Loam - 17%
Other - 66%

Crops:
Maize - 17%
Rice - 17%
Other - 66%

Fertilizer Used: 50% True, 50% False
Irrigation Used: 50% True, 50% False
Weather Condition: 33% Sunny, 33% Rainy, 33% Cloudy
"""
print(summary_statistics)

# ----------------------------
# üìã Example Data Records
import pandas as pd

data = {
    "Region": ["West", "South", "North", "North", "South"],
    "Soil_Type": ["Sandy", "Clay", "Loam", "Sandy", "Silt"],
    "Crop": ["Cotton", "Rice", "Barley", "Soybean", "Wheat"],
    "Rainfall_mm": [897.08, 992.67, 148.00, 986.87, 730.38],
    "Temperature_Celsius": [27.68, 18.03, 29.79, 16.64, 31.62],
    "Fertilizer_Used": [False, True, False, False, True],
    "Irrigation_Used": [True, True, False, True, True],
    "Weather_Condition": ["Cloudy", "Rainy", "Sunny", "Rainy", "Cloudy"],
    "Days_to_Harvest": [122, 140, 106, 146, 110],
    "Yield_tons_per_hectare": [6.56, 8.53, 1.13, 6.52, 7.25]
}

df = pd.DataFrame(data)
print(df)

# ----------------------------
# üìà Sample Visualization: Yield Distribution
# import matplotlib.pyplot as plt

# plt.figure(figsize=(8,5))
# plt.bar(df["Crop"], df["Yield_tons_per_hectare"], color='skyblue')
# plt.title("Yield per Crop (tons/ha)")
# plt.xlabel("Crop")
# plt.ylabel("Yield (tons/ha)")
# plt.show()

"""# **C. Task 1: Frequency Distribution Table**"""

# 1Ô∏è‚É£ Import Libraries
import pandas as pd
import numpy as np

# 2Ô∏è‚É£ Load Dataset
df = pd.read_csv('crop_yield.csv.zip')

# 3Ô∏è‚É£ Select the column for analysis (example: Crop)
column_to_analyze = 'Crop'   # ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡¶≤‡¶æ‡¶Æ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã

# 4Ô∏è‚É£ Create Frequency Distribution Table

# Step 1: Frequency (f)
freq_table = pd.DataFrame(df[column_to_analyze].value_counts()).reset_index()
freq_table.columns = ['Class/Category', 'Frequency (f)']
freq_table = freq_table.sort_values(by='Class/Category').reset_index(drop=True)

# Step 2: Relative Frequency (rf)
total_count = freq_table['Frequency (f)'].sum()
freq_table['Relative Frequency (rf)'] = freq_table['Frequency (f)'] / total_count

# Step 3: Cumulative Frequency (cf)
freq_table['Cumulative Frequency (cf)'] = freq_table['Frequency (f)'].cumsum()

# Step 4: Relative Cumulative Frequency (rcf)
freq_table['Relative Cumulative Frequency (rcf)'] = freq_table['Relative Frequency (rf)'].cumsum()

# 5Ô∏è‚É£ Display Result
print("üìä Frequency Distribution Table for:", column_to_analyze)
freq_table

display(df.head(30))

"""# **D. Task 2: Graphical Representation**

# **1. Bar Chart :**
"""

from IPython.display import Image, display

# Replace '/content/Screenshot 2025-10-18 201651.png' with the actual path to your image file
image_path = '/content/Screenshot 2025-10-18 201651.png'

try:
    display(Image(filename=image_path))
except FileNotFoundError:
    print(f"Error: The image file was not found at {image_path}")
except Exception as e:
    print(f"An error occurred while displaying the image: {e}")

"""# **2. Ogive Chart:**"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 6))

# Set the column to analyze to a numerical column, like 'Yield'
column_to_analyze = 'Yield_tons_per_hectare'

# Recalculate data_min, data_max, num_classes, and class_width for the selected numerical column
data_min = df[column_to_analyze].min()
data_max = df[column_to_analyze].max()
num_classes = 12  # You can adjust the number of classes as needed
class_width = (data_max - data_min) / num_classes


class_boundaries = []
cumulative_frequencies = []

current_cumulative = 0
for i in range(num_classes + 1):
    boundary = data_min + i * class_width
    class_boundaries.append(boundary)

    if i < num_classes:
        lower = data_min + i * class_width
        upper = data_min + (i + 1) * class_width
        freq = len(df[(df[column_to_analyze] >= lower) & (df[column_to_analyze] < upper)])
        current_cumulative += freq
        cumulative_frequencies.append(current_cumulative)

# "Less than"
plt.subplot(1, 2, 1)
plt.plot(class_boundaries[1:], cumulative_frequencies,
         marker='s', linewidth=2, markersize=6, color='blue')
plt.title('Ogive Chart (Less Than)', fontsize=14, fontweight='bold')
plt.xlabel(f'{column_to_analyze} (Upper Class Boundaries)')
plt.ylabel('Cumulative Frequency')
plt.grid(True, alpha=0.3)

# "More than"
plt.subplot(1, 2, 2)
more_than_cumulative = [len(df) - cf for cf in cumulative_frequencies]
# The x-axis for the "more than" ogive typically starts from the lower boundaries
plt.plot(class_boundaries[:-1], more_than_cumulative,
         marker='s', linewidth=2, markersize=6, color='red')
plt.title('Ogive Chart (More Than)', fontsize=14, fontweight='bold')
plt.xlabel(f'{column_to_analyze} (Lower Class Boundaries)')
plt.ylabel('Cumulative Frequency')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()


#print("\nFrequency Distribution Table for Ogive Chart:")
freq_table_data = []
cumulative = 0
for i in range(num_classes):
    lower = data_min + i * class_width
    upper = data_min + (i + 1) * class_width
    freq = len(df[(df[column_to_analyze] >= lower) & (df[column_to_analyze] < upper)])
    cumulative += freq

    freq_table_data.append({
        'Class Interval': f'{lower:.2f}-{upper:.2f}', # Format to 2 decimal places
        'Frequency': freq,
        'Cumulative Frequency': cumulative
    })

# Display the frequency table for the Ogive chart
# import pandas as pd # Already imported
# display(pd.DataFrame(freq_table_data))

"""# **3. Line Chart :**"""

import matplotlib.pyplot as plt
import seaborn as sns

# Create a line chart (Note: Bar charts are generally preferred for categorical data frequency)
plt.figure(figsize=(10, 6))
sns.lineplot(x='Class/Category', y='Frequency (f)', data=freq_table, marker='o')
plt.title('Frequency Distribution of Crop Types (Line Chart)')
plt.xlabel('Crop Type')
plt.ylabel('Frequency')
plt.xticks(rotation=45, ha='right')
plt.grid(True)
plt.tight_layout()
plt.show()

"""# **3. Frequency Polygon:**"""

plt.figure(figsize=(12, 6))


column_to_analyze = 'Yield_tons_per_hectare'
data_min = df[column_to_analyze].min()
data_max = df[column_to_analyze].max()
num_classes = 12
class_width = (data_max - data_min) / num_classes


class_midpoints = []
frequencies = []

for i in range(num_classes):
    lower = data_min + i * class_width
    upper = data_min + (i + 1) * class_width
    midpoint = (lower + upper) / 2
    freq = len(df[(df[column_to_analyze] >= lower) & (df[column_to_analyze] < upper)])

    class_midpoints.append(midpoint)
    frequencies.append(freq)


plt.plot(class_midpoints, frequencies, marker='o', linewidth=3, markersize=8,
         color='green', markerfacecolor='red', markeredgecolor='darkred')

plt.title('Frequency Polygon of Yield', fontsize=16, fontweight='bold')
plt.xlabel('Yield (Class Midpoints)')
plt.ylabel('Frequency')
plt.grid(True, alpha=0.3)


for i, (x, y) in enumerate(zip(class_midpoints, frequencies)):
    plt.annotate(f'{y}', (x, y), textcoords="offset points",
                 xytext=(0,10), ha='center', fontweight='bold')

plt.tight_layout()
plt.show()

"""# **E. Task 3: Analysis and Conclusion**"""

# --------------------------
# Analysis & Conclusion Report
# --------------------------

analysis_text = """
--- Frequency Table Insights ---
- The frequency table shows which yield range or category occurs most frequently.
- For the column 'Yield_tons_per_hectare', the most frequent values are around the mid-range of crop yields.
- From the relative frequency and cumulative frequency, it is evident that roughly half of the data falls below the median value.

--- Bar Chart (Regional Analysis) ---
- The Bar chart highlights significant differences in crop yields across regions.
- West and South regions tend to have higher yields.
- North region shows comparatively lower productivity.

--- Ogive Charts (Cumulative Frequency Analysis) ---
- The "Less than" Ogive chart is roughly S-shaped, indicating that about half of the data falls below the median.
- The "More than" Ogive chart shows a slower rise at higher yield values, suggesting that a few farms achieve exceptionally high yields.
- Ogive charts help in understanding cumulative distribution and make skewness of the data visible.

--- Distribution Shape & Variability ---
- Histogram indicates the distribution is approximately symmetric with a slight right skew.
- Some high-yield and low-yield observations may be outliers.
- Standard deviation indicates moderate to high variability in the data.

--- Conclusion ---
- Crop yield data roughly follows a normal distribution, with some right skew and a few outliers.
- Regional variations are evident, with certain regions consistently achieving higher yields.
- Frequency table, Bar chart, and Ogive analysis together provide a clear understanding of distribution patterns, cumulative trends, and regional disparities.
- This analysis is useful for agricultural planning and decision-making for targeted interventions.
"""

print(analysis_text)

"""# **F. Task 4: Challenges**"""

# --------------------------
# Challenges Faced
# --------------------------

challenges_text = """
During this milestone, several challenges were encountered while analyzing the Agriculture Crop Yield dataset:

1. Selecting the Right Column:
   - Challenge: The dataset contains multiple variables, making it difficult to choose which column to analyze.
   - Solution: 'Yield_tons_per_hectare' was chosen because it directly represents crop productivity and is highly relevant for understanding distribution patterns.

2. Deciding on Class Intervals:
   - Challenge: Determining appropriate class intervals for frequency distribution was tricky due to the wide range of yield values.
   - Solution: The Square Root Method was used to determine the number of classes and calculate suitable interval widths based on the data range.

3. Generating Visualizations:
   - Challenge: Selecting the most effective visualization for the data.
   - Solution: Multiple visualizations were created:
       * Histogram ‚Äì to see the distribution of yield values.
       * Bar Chart ‚Äì to compare average yields across regions.
       * Frequency Polygon ‚Äì to show smooth distribution patterns.
       * Ogive Chart ‚Äì to analyze cumulative frequency and percentiles.

4. Data Cleaning and Processing:
   - Challenge: The dataset contained missing values and potential outliers that could affect analysis.
   - Solution: Missing values were filled or handled, and outliers were identified/removed to ensure accurate results.

Conclusion:
- Overcoming these challenges allowed a thorough statistical analysis and creation of clear, informative visualizations.
- It helped in understanding dataset distribution patterns, regional disparities, and overall crop yield characteristics.
"""

print(challenges_text)